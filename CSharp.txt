01_IntroToDotNet
 

Credential Manager

C# - побудована і працює на платформі .NET

.NET Core дозволяє створюватти кросплатформенні додатки

C#  - це чисто ПОО мова програмування

Середовища виконання: Command langauge Run Time (CLR)
CLR - менеджер між нашими класами, бібліотеками і операційною системою. Виділяє і чистить память.



visual studio installer -> modify -> .net deskstop development -> instal

cw + TAB - Console.WriteLine("") - вивести на екран

C# data types  - static
	Value types  -  unNullable 
		Simple types (int, float, char, bool
		enum, 
		struct 
		
	Reference Rypes - dynamic - Nullable 
		Class, array, interface, delegate
		
Типи данних:
	Цілі:
		byte  	 0 > 255
		sbyte	-128>127
		short	int16   -32 768 > 32767 
		ushort  0>65535
		int		- int32
		uint	
		long	-int64
		ulong
	Дробові:
		float (single)   - float h = 3.14f;
		double
		decimal   -  decimal p = 5.64m;
		
Console.Readline()!;

int number = int.Parse(str); 

Console.WriteLine($"Number {numberStr}"); - інтерполяція


Console.OutputEncoding = Encoding.Unicode;
                \'      – single quote, needed for character literals
                \"      – double quote, needed for string literals
                \\      – backslash
                \0      – Unicode character 0
                \a      – Alert (character 7)
                \b      – Backspace (character 8)
                \f      – Form feed (character 12)
                \n      – New line (character 10)
                \r      – Carriage return (character 13)
                \t      – Horizontal tab (character 9)
                \v      – Vertical quote (character 11)
                \uxxxx  – Unicode escape sequence for character with hex value xxxx   
	
cw + TAB - Console.WriteLine("")
Console.Readline()!;

            //изменяет цвет фона
            Console.BackgroundColor = ConsoleColor.Green;
            //изменяет цвет текста                      
            Console.ForegroundColor = ConsoleColor.Magenta;
			Console.ResetColor();

DateTime now = DateTime.Now;

cw + TAB - Console.WriteLine("") - вивести текст
Console.Write($"Number {i + 1}: "); - без переходу на новий рядок
	$"..." — це рядкова інтерполяція: дозволяє вставляти значення змінних або виразів прямо всередину рядка.
	Усередині фігурних дужок {} можна писати змінні або вирази.
string input = Console.ReadLine(); - зчитати текст
numbers[i] = int.Parse(Console.ReadLine())!; - int.Parse — перетворює рядок у ціле число

int[] numbers = new int[5]; - массив

	foreach (int num in numbers)
        {
		sum += num;
        product *= num;
        if (num < min) min = num;
        if (num > max) max = num;
        }





========================================================
02_Array

Array - батьківський клас всіх масивів. Зберігаються в динамічній памяті

Створення нового масиву
Пустий масив:
	int[] arr = new int[8];
Пусті комірки зайняті нулями

int[]arr2 = new int[] {1,2,3,4,5}; - список інізіалізації, саме рахує кількість елементів, можна сайз не вказувати

	int []arr4 = [10,20,30]; - коротший варінт
	
	arr5.SetValue(77,2;
	
	for може редагувати, лізе в кожну комірку по індексу
	
	foreach (var elem in arr5) - може тільки виводити, бо кожне значення копіює в змінну елем, немає доступу до оригіналу, і є готовий інумінатор

Двовимірний масив:
	int[,] array = new int [3,3];
	
	array.Length - загальна кількійсть комірок
	array.GetLength(0) - показує довжину рядка

є тровимірні і так далі

Рваний масив (зубчастий) - двовимірний масив - є рядочкі, але в рідках різна кількість комірок
	int[][] jagged = new int[3][];

	int[] temparr = (int[]) arr.Clone(); - клонування масива

        Random random = new Random();
        double res = random.Next(100) + random.NextDouble();
        Console.WriteLine(res);

		res = Math.Round(res, 2); - обрізати до 2 символів після коми
        Console.WriteLine(res);


static function?
abstruct ?

	
========================================================
03_String
	
	string[] array = { "Hello", "From", "Summer", "Sun", "Tree", "Lake" };
	
	string message = string.Join(" - ", array); - з масиву стрінг у одну стрінгу
	
	string []splictArr = message.Split(new string[] {" - "}, StringSplitOptions.None); - просто порізати по розділювачу
	
	string []words = htmlMessage.Split(new char[] { ' ', '.', ',', '!', '/', '-', '?' }, StringSplitOptions.RemoveEmptyEntries); - порізати по купі розділювачів, і з опцією не враховувати пробіли 
	
	ConsoleKeyInfo key =  Console.ReadKey(); - бере один "ключ" - кнопку на клавіатурі
	if(key.Key == ConsoleKey.F12) - от тут нажата ф12

	if (string.IsNullOrEmpty(nullStr) або просто посилання, або стрінга створена з "" (тобто пуста)
	if (string.IsNullOrWhiteSpace(str2)) - або просто посилання або пробіли
	
Зрівнюємо 2 стрінги
	
	if (string.Compare(str11, str12) == 0)
	
String Contains String

    string str3 = "This is testing";
    if (str3.Contains("test"))	
	
Вирізати частину тексту
	string substr = str4.Substring(23); - з 23 індексу до кінця
	string substr = str4.Substring(23,5); - з 23 індексу 5 символів
	
Зєднуємо стрінги з массиву в одну
            string[] starray = new string[]{"Down, the way nights, are dark",
                                            "And the sun shines daily on the mountain top",
                                            "I took, a trip, on,a sailing ship",
                                            "And when I reached Jamaica",
                                            "I made a stop"};

            string str5 = string.Join("!\n", starray);
	
Конкатанація (додавання)
            string s1 = "hello";
            string s2 = "world";
            string s3 = s1 + " " + s2; // = string "hello world"
	
03_02_StringBuilder

	StringBuilder stringBuilder = new StringBuilder(); - кожен раз як не влазить новий розмір зарезервованих комірок в 2 р більше

	Console.WriteLine("Capacity : " + stringBuilder.Capacity); - кількість зарезервованих комірок
	Console.WriteLine("Length : " + stringBuilder.Length); - кількість зайнятих комірок
	
	stringBuilder.Append("Hello"); - додаємо в кінець
	stringBuilder.AppendLine("Hello"); - додає і в кінці \n

========================================================
04_IntroToOOP

class - можливість зробити свій тип данних

	private, public, protected - так само як на С++
	internal - дає доступ тільки до цього класу тільки в цьому проєкту
	protected internal - наслідники в межах цієї збірки (проекта)
	
class Point
{
	private int numder;   (для кожної змінної прописуємо 

}
дочірній клас:
class Child: Point  (public по замовчуванні і змінити не можеш)



	class Point
{
		private int numder;   (для кожної змінної прописуємо 
		private string name;
		privat const float PI=3.14f;   - не можна інізіалізувати в 	конструкторі
		private readonly int id = 1; - можна інізіалізатувати в конструкторі

}



partial class Point : Object - в любому випадку батьківський класс обж, партіал дає можливість розділити класс на частини


Property - це властивість яка робить змінну контрольованою, всередині ми можемо зробити валідацію.


fullproperty ---> propfull + Tab



partial class Point
    {
        private int xCoord;   - приватна змінна
 
        public int XCoord      - проперті до цієї змінної (
        {
            get { return xCoord; }
            set
            {
                if (value >= 0)			- перевірка для сеттера
                    xCoord = value;
                else
                    xCoord = 0;
            }
        }
        private int yCoord;
        public int YCoord
        {
            get { return yCoord; }
            set
            {
                if (value >= 0)
                    yCoord = value;
                else
                    yCoord = 0;
            }
        }

автопроперті:
Auto property ---> prop + Tab

public string Name { get; set; } - автопроперті
		
		
		
		
		
		public void Print()  - принт по старинці
        {
            Console.WriteLine($"X : {xCoord}, Y : {yCoord}");
            //Console.SetCursorPosition(xCoord, yCoord); Console.WriteLine("*");
        }
        public override string ToString() - перевантажена функція від батьківського классу
        {
            return $"X : {xCoord}, Y : {yCoord}";
        }
		
		
		    p.XCoord = 1000;   //value = 1000 - setter
            Console.WriteLine(p.XCoord);    //getter
		
		
для звернення до проперті в майн:

	
Worker w = new Worker;

w.Name - якщо немає дорувнює, спрацьовує гетер і виведе значення

w.Age = 18; - є дорівнює, спрацьовує сеттер і запише нове значення




struct NewPoint { -  структура не може мати наслідників


поділ на файли
partial - дозволяє ділити класси на частини

			static

Статичне поле — це змінна, яка:
	належить не конкретному об’єкту, а всьому класу в цілому;
	існує в єдиному екземплярі незалежно від кількості створених об'єктів;
	має спільне значення для всіх екземплярів класу.
Статичний метод — це метод, який також належить класу, а не окремому об’єкту, і може працювати тільки зі статичними полями або параметрами.

 Что такое статический конструктор в C#?
Статический конструктор — это специальный конструктор, который:
	выполняется автоматически один раз, перед первым использованием класса (до создания первого объекта или вызова любого статического члена).
	не принимает параметров
	не вызывается вручную
	используется для инициализации статических полей

========================================================
05_StructRefOut

struct NewPoint { -  структура не може мати наслідників, все що є в середині паблік
Містить конструктор і прінт



Якщо треба мати два класса з однією назваою, можна розбивати на namespase

_2D_Object.Point p   - вказуємо найм спейс якщо мейн не в цьому неймспейсі

Ref - references - створює посилання по якій буде давати доступ до оригіналу

Point point = new Point() {X = 10, Y = 15}  - створення обєкту без конструктора

        static void Modify(int num, string str, Point point)
        {
            num += 1;
            str += "!!!";    просто копії і стираються, оригінал не зміниться, бо це валує тип
            point.X++;
            point.Y++;   приходить копія посилання, оригінал зміниться
        }


	!!!Дуже важливо копію чого ми передаємо

в валує просто копія
в референс передається копія адреси
для стрінги і масивів не підходить, бо перевидається память і нова адреса

ref - це посилання, замість & в плюсах
Це ключеве слово, яке передає доступ до оригіналу з середини методу

!!!Може дозволяє змінити тількі інізіалізовану змінну

        }
        static void Modify(ref int num, ref string str, ref Point point)
        {
            num += 1;
            str += "!!!";
            point.X++;
            point.Y++;  
        }
	
ref - працює з оригіналом, якщо змінна не ініціалізована, помилка

Out  - працює з оригіналом, але може сам ініціалізувати змінні, навіть якщо вони не ініціалізована, або навіть не створена


        static void GetCurrentTime(out int hour,out  int minute ,out int second)
        {
            hour = DateTime.Now.Hour;
            minute = DateTime.Now.Minute;
            second = DateTime.Now.Second;
                    
        }
main
            GetCurrentTime(out h,out m, out s);
            
            Console.WriteLine($"{h}:{m}:{s}");

Змінних h, m, s не існувало в мейні. Коли визвалась функція static void GetCurrentTime(out int hour,out  int minute ,out int second), всередині функції були зроблені змінні hour, minute, second, ініціалізовані, і збережені у вигляді нових змінних ззовні (у мейн) h,m,s


Структури зберігається в стекі
Класси в динамічній памяті, АЛЕ:

	new

Коли ми робимо пустий КЛАСС,  запускається ДЕФОЛТНИЙ КОНСТРУКТОР і створюється послання і точно виділяється динамічна память і заповнюються нулями

в СТРУКТУРІ дефолтний конструктор чипати не можна, бо він запускається і записує в СТЕК дефлотні значення

	
========================================================
06_Exception


if (y==0)
{
	throw new Exception ("описуємо від себе помилку")
}


try  -запускає код
{
	ризикований код
}
catch (Exception ex) - ловить помилку
{
    Console.WriteLine($"Error: {ex.Message}");
}

finaly   - це такий блок який запускається безумовно в кінці трай, туди пишемо закриття файлів, підключень і тд
{
	
}  


	byte b = 100;
	b = (byte)(b+200); - переповнено, ма
	
try
	checked   - перевіряє
		b++;
		
		
	unchked
	
	byte b = 100;
	
	
				Namespace
				
Можна робити різні неймспейси, і розміщювати класи з одним імям в кожному і через неймспейси посилатись

A.Incrementer()  - функція з неймспейс А

using A;   - підключяаємо просто цей нейспейс А

    https://github.com/IliushynOlena/Exceptions
    https://github.com/IliushynOlena/c_charp_namespaces

========================================================
07_OverloadOperator


    class _3D_Point
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Z { get; set; }
		.........


       class Point
    {
        public int X { get; set; }
        public int Y { get; set; }
        public Point() : this(0, 0) { }

        public Point(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }
        public override string ToString()
        {

            return $"X: {X}. Y : {Y}";
        }

        public override bool Equals(object? obj) - наводим на слово клас, лампоча і пункт меню
        {

            return obj is Point point &&
                   X == point.X &&
                   Y == point.Y;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(X, Y);
        }

        // ref and out not allowed
        //public static return_type operator [symbol](parameters )
        //{
        //code
        //}
		
		
		
			Унарні оператори
			-	не змінює оригінал а повертає новий поінт
		
			
        public static Point operator -(Point point)
        {
            Point res = new Point
            {
                X = -point.X,
                Y = -point.Y
            };
            return res;
        }
        public static Point operator ++(Point point)    -завжди міняє оригінал, виводить ++point (все одно спрацьовує префіксна форма, навіть коли вказується point++
        {
            //a++
            //a = a + 1
            point.X++;
            point.Y++;
            return point;
        }
        public static Point operator --(Point point)
        {
            point.X--;
            point.Y--;
            return point;
        }

        
			Бінарні оператори
		
		
        public static Point operator +(Point p1, Point p2)
        {
            Point res = new Point
            {
                X = p1.X + p2.X,
                Y = p1.Y + p2.Y
            };
            return res;
        }
        public static Point operator -(Point p1, Point p2)
        {
            Point res = new Point
            {
                X = p1.X - p2.X,
                Y = p1.Y - p2.Y
            };
            return res;
        }
        public static Point operator *(Point p1, Point p2)
        {
            Point res = new Point
            {
                X = p1.X * p2.X,
                Y = p1.Y * p2.Y
            };
            return res;
        }
        public static Point operator /(Point p1, Point p2)
        {
            Point res = new Point
            {
                X = p1.X / p2.X,
                Y = p1.Y / p2.Y
            };
            return res;
        }
        
        
			Оператори порівняння < >  <= >=
			
					
        public static bool operator <(Point p1, Point p2)
        {
            return p1.X + p1.Y < p2.X + p2.Y;
        }
        
        public static bool operator >(Point p1, Point p2)   - для перезавантаження треба зробити ще оператор >, вони працюють в парі
        {
            //return p1.X + p1.Y > p2.X + p2.Y;
            return !(p1 < p2);
        }
        public static bool operator <=(Point p1, Point p2)
        {
            return p1.X + p1.Y <= p2.X + p2.Y;
        }
        
        public static bool operator >=(Point p1, Point p2)
        {
            //return p1.X + p1.Y > p2.X + p2.Y;
            return !(p1 <= p2);
        }

		
		
			Оператори рівності ==, !=
			

        public static bool operator ==(Point p1, Point p2)
        {
            return p1.Equals(p2);
        }

        public static bool operator !=(Point p1, Point p2)
        {
            return !(p1 == p2);
        }


			true/false operators
			
        public static bool operator true(Point p)
        {
            return p.X != 0 || p.Y != 0;
        }
        //in pair
        public static bool operator false(Point p)
        {
            return p.X == 0 && p.Y == 0;
        }

			Overload types - перезавантаження типів даних
			
			
        public static implicit operator int(Point p)
        {
            return p.X+ p.Y ;
        }
        public static explicit operator double(Point p)
        {
            return p.X + p.Y;
        }
        public static explicit operator _3D_Point(Point p)  -   _3d_Point це і назва оператора і результат ретурна
        {
            return new _3D_Point(p.X, p.Y, 100);
        }
        #endregion
    }
	

========================================================
08_01_Inheritance
Наслідування

Питання - чи являється?
Лев являється твариною? Так
велосипед являється твариною? ні

В C# не підтримує множинне наслідування, клас може мати тільки один батьківській клас

new DateTime();  -  save 01.01.0001
DataTime.Now  - це час на данний момент


abstract class Person  (завжди є наслідником Object) - абстрактний класс (не можна створювати обєкт)

sealed - забороняє перевизначати наслідниками цього методу, або забороняє наслідування классу
	print 
        
		//abstract method the same  void DoWork() = 0;
		
        public abstract void DoWork();
		- асбтрактний метод (пустий де немає ніякої реалізації)


///
class Name : BaseClass, Interface1, (батьківський клас тільки один, інтерфейсів може бути безліч)
///

class sealed Name: worker  сиалед- забороняє унаслідувати цей клас

class Worker : Person  -  наслідування за персон
{
	....

        public Worker(string name, DateTime b, int salary):base(name, b)
        {
            Salary = salary;
        }  - конструттор з делегуванням до батьківського класу, по ключовому слові бейс
	
        public override void DoWork()  - - override писати обовязково
        {
            Console.WriteLine("Doing some work....");
        }
        // new  - create new member and stop virtual
        //override - перевизначаємо метод батьківського класу
		
        public override void Print()
        {
            base.Print();
            Console.WriteLine($"Salary : {Salary}");
        }
    
	- base.Print(); - делегуємось до батьківського клас. 
	
class Programmer : Worker  
...

class TeamLead : Programmer
        public override void DoWork()
        {
            Console.WriteLine("Manage team project!!!");
        }


main 
	
            // ----------- 3 - use IS and AS

            if (persons[1] is Programmer)
            {
                pr = persons[1] as Programmer;
                pr.DoWork();
            }
            else
            { Console.WriteLine("Object is null"); }
			
			-якщо він реально є програмістом, то виконується код   
	
	
	
property не може бути virtual 

Механізм пізнього зв'язування (Late Binding) у C# — це можливість викликати методи або отримувати властивості об’єкта під час виконання програми (runtime), а не під час компіляції (compile-time). У C# пізнє зв’язування реалізується через ключове слово dynamic або інтерфейс System.Reflection.


========================================================
08_02_Indexers
Індекскатор


class Laptop 
		...
		
class Shops
{
	Laptop[] laptops;
	
	!!!!!


        public Laptop this[int index]
        {
            get
            {
                if (index >= 0 && index < laptops.Length)
                {
                    return laptops[index];
                }
                throw new IndexOutOfRangeException();
            }
            set
            {
                if (index >= 0 && index < laptops.Length)
                {
                    laptops[index] = value;
                }
            }
        }
		- двохсторонній
		-value це new Laptop і тд
		
        public Laptop this[string name]
        {
            get 
            {
                foreach (var l in laptops)
                {
                    if(l.Model == name)
                        return l;
                }
                return null;
            }  
			- по назві
	
========================================================
09_Interfaces

Інтерфейс - це клас який маює методи тільки без реалізації (чисто віртуальні)

Імплементація - обіцяю зробити все методи що в інтерфейсах.
НЕ НАСЛІДУВАННЯ а імплементація 

Всередині інтерфейсу ми можемо прописувати протиотипи методів без їхньої реалізації. Тип повернення будь який, кількість параметрів будь яка

проперті, але вони мають бути тільки порожні 
Також event 

Всередині специфікатор доступу паблік, не можна робити приватні змінні

class Human
{
	...
	!!!!to string      - зробили принт тільки з своєю реалізаціїєю
}


abstract class Employee : Human -вказуємо абстракт щоб заборонити робити обєкти цього класу
{
	!!! ту стрінг   - в цьому методі вже використовуємо реалізацією від басе (хуман) і доповнили своїми новим рядочком
}

interface IWorkable
{
	string Work();
	bool IsWorking{get, } 
}

interface IManager  - прийнято інтерфейси починати з І
{
	List<Employee> ListOfWorkers {get,set;}
	void Organize();
	...
}

class Director: Employee, IManager - імплемінтація чи реалізація
Нажимаєм лампочку і шаблони вискачать

class Seller:Employee, Iworkable {...}

class Cashier : Employee, IWorkable

class Administrator : Employee, IWorkable, IManager 
	


main 
{		інтерефейсне посилання - дає доступ тільки до методів іменежер
	IManager director = new Director - має доступ тільки до методів і змінних IMnager
	
	(бо Director director = new Director - дає доступ до всього)
	
	
	
	director.ListOfWorkers = new List<Employee> { ....}
	
	по дефолту воно директора сприймає як манагер, а якщо так написати
	
	(director as Director)!.Salary = 30000; - тепер маєм доступ як до директору
	
	
	Administrator	admin = new Administrator(); 
	
	IManager manager = admin;   - інтерфейсне посилання (даємо доступ до цього інтерфейсу)
	
	
	manager.   - тільки з ІМанажер
		
}

========================================================
10_StandartInterfaces
Стандартні інтерфейси

    class StudentCard :ICloneable 
    {
        public int Number { get; set; }
        public string Series { get; set; }

        public object Clone()
        {
            return this.MemberwiseClone();
        }

        public override string ToString()
        {
            return $"Students Card : {Number} . {Series}";
        }
    }

 class Student : IComparable<Student>, ICloneable 
    {
	
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime Birthdate { get; set; }
        public StudentCard StudentCard { get; set; }

        public object Clone() - скопіювати обєктор
        {
            temp.StudentCard =(StudentCard) this.StudentCard.Clone();
            return temp;
        }
       public int CompareTo(Student? other) - зрівнюємо
        {
            return FirstName.CompareTo(other!.FirstName);
        }

        public override string ToString()
        {
            return $"Fullname : {FirstName} {LastName}. Birthdate : " +
                $"{Birthdate.ToLongDateString()}. {StudentCard.ToString()}";
        }
    }

    class Auditory : IEnumerable
    {
    
        Student[] students;
        public Auditory()
        {
            students = [
                new Student
                {
                     FirstName = "Ivan",
                     LastName = "Popchuk",
                     Birthdate = new DateTime(2000,12,7),
                     StudentCard = new StudentCard { Number = 123456, Series = "AAA" }
                },
                 new Student
                {
                     FirstName = "Olga",
                     LastName = "Oliunuk",
                     Birthdate = new DateTime(2005,12,7),
                     StudentCard = new StudentCard { Number = 111111, Series = "BB" }
                },
                  new Student
                {
                     FirstName = "Mukola",
                     LastName = "Ivanchuk",
                     Birthdate = new DateTime(1999,8,17),
                     StudentCard = new StudentCard { Number = 222222, Series = "CC" }
                },
                   new Student
                {
                     FirstName = "Mira",
                     LastName = "Polishuk",
                     Birthdate = new DateTime(2002,12,7),
                     StudentCard = new StudentCard { Number = 333333, Series = "DD" }
                },
                    new Student
                {
                     FirstName = "Yura",
                     LastName = "Popchuk",
                     Birthdate = new DateTime(2001,12,7),
                     StudentCard = new StudentCard { Number = 444444, Series = "FF" }
                }
            ];
        }

        public IEnumerator GetEnumerator()    - вказуємо що від арея брати інумінатор
        {
            return students.GetEnumerator();  - ми берем від студентів інумінатор (смарт поінт), для того щоб можна було форічем
        }

        public void Print()
        {
            foreach (Student st in students)
            {
                Console.WriteLine(st);
            }
        }
        public void Sort() - для стандартного сортування від арей
        {
            Array.Sort(students); 
        }
        public void Sort(IComparer<Student> comparer) - для іншого сортування, IComparer<Student> або IComparer<Student>
        {
            Array.Sort(students,comparer);
        }
    }	
    class LastNameComparer : IComparer<Student> - створюємо comparer
    {
        
        public int Compare(Student? x, Student? y)
        {
            return x!.LastName.CompareTo(y!.LastName);
        }
    }
    class BirthdateComparer : IComparer<Student> створюємо comparer
    {
        public int Compare(Student? x, Student? y)
        {
            return x!.Birthdate.CompareTo(y!.Birthdate);
        }
    }
	
    internal class Program
    {
        static void Main(string[] args)
        {	
			Auditory auditory = new Auditory();
			
            foreach (Student st in auditory) - для цього ми в класі аудиторія робили гет інумінатор (смарт поінтер)
            {
                Console.WriteLine(st.ToString());
            }			
	
            Console.WriteLine("-------------- Sort array -------------");
            auditory.Sort(); - 	звичайне сортування від арей
            foreach (Student st in auditory)
            {
                Console.WriteLine(st.ToString());
            }	
            Console.WriteLine("-------------- Sort array by last name -------------");
            auditory.Sort(new LastNameComparer()); 
			
			- робимо новий обєкт comparer і передаємо його одразу в функцію Sort(IComparer<Student> comparer)
			
            foreach (Student st in auditory)
            {
                Console.WriteLine(st.ToString());
            }


	

може бути може не бути - агрегація
має обовязково бути - композиція
так от тут StudentCard має бути обовязково




========================================================
10_01

Enum  - набір цілочисельний констант 



    enum DayOfWeek//const int Monday = 0, Tuesday = 1 і тд
    {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
    }
	
	
main 

            string[] names = Enum.GetNames(typeof(DayOfWeek));
            foreach (var item in names)  
            {
                Console.WriteLine(item);
            }  - вивід назв в енамі


            DayOfWeek[] values = (DayOfWeek[])Enum.GetValues(typeof(DayOfWeek));

            foreach (DayOfWeek item in values)
            {
                Console.WriteLine($"{item} - {(int)item}");
            } - вивід чисел в енамі 
	
========================================================
11_Delegates

Вказівники на функцію

Делегат - це ссилочний тип який дозволяє зберігати посилання на методи або функції заданої сигнатури. Це иакож "класс", але єдине що може - зберігати посилання

Сигнатура =  прототип  - void Print() 

Назва методу без () це завжди адреса

Перше, специфікатор доступу
тип повернення

те саме що public class VoidDElegate : MulticastDelegate 

от так:

public delegate void VoidDelegate();



public void Print(string str) {}
робимо делегат:

public delegate void SetStringDelegate(string s);
на делегат можна записати декількох методів, аби тип повернення був такий же і тип кількість аргументів. 
Назва методу і назва делегату немає значення

DoubleDelegate delog = SuperClass.GetKoef; - вказівник на фунццію, тип данних DoubleDelegate - це створений нами делегат з певним типом повернення і кількістью аргументів

Делегати необхідність для віконних додатків. Ми не можемо передбачити що вибере користувач.

На кожну кнопку має бути делігат, який зберігає посилання на метод, що має запуститись

deleg?.Invoke() - перевірка на null


робимо масив делегатів:

DoublDelegate [] doubleDelegate = new DoubleDelegate[2[ {
	SuperClass.GetKoef,
	superClass.GetNumber
}

SetStringDelegate setString = new SetStringDelegate(superClass.Print);
setString.Invoke("Hello");

VoidDelegate voidDelegate = super.DoWork; - записали один метод
VoidDelegate.Invoke();  - запустили посилання

Записати пару методів на один делегат:

voidDelegate += superClass.Test;  - обєднуються разом в перший делегат

voidDelegate.Invoke(); - запустились обидва методі в делегаті


Лямбда вирази


public delegate int ChangeDelegate(int a);

static void ChangeArr(int[]arr)
{
	for	(int i = 0; i<arr.Length; i++)
	{
		arr[i] = change(arr[i]);
	}
}
static int SQRT(n)
{...}


main

	int[] arr = new int {...}
	ChangeArr(arr,SQRT); - в функцію ченж вставив функцію яку використовувати
	
Анонімний делегат - anonymus delegate

	ChangeArr(arr, delegate (int n) {return n*n;});
	
lambda expresion - лямбда вирази

	ChangeArr(arr, (n)=> n*n);
	
	
========================================================
12_EventCallBackFunction

CallBackFunction - це передача в метод делегата, який має запуститись в кінці нашого методу

	HardWork(delegate () {Console.WriteLine("Good");});

Коли відбувається подія, ПІДПИСНИК на неї реагує



		private делегат + public event
		
	public event ExamDelegate ExamDelegate;


Подія
Event - Створює приватний делегат і дає публічний доступ через += і -=. Іншими словами, беспечний делегат.


main
	
	можемо в делегат додавляти чи видаляти методи завдяки += і -=
	
Розгорнутий ивент - full property


        private ExamDelegate _examDelegate;
        public event ExamDelegate ExamEvent
        {
            add 
            { 
                _examDelegate += value;
                Console.WriteLine(value.Method.Name + " was added");
            }
            remove 
            { 
                _examDelegate -= value;
                Console.WriteLine(value.Method.Name + " was removed");
            }
        }
	

public Action TestEvent; - це вбудованний варінт делегата
========================================================
12_01_ExtensionMetod

Метод розширення - це 


Нам треба в бібліотеку додати свій метод, щоб він відображався як з тої бібліотеки

Для додавання методу до стрінги

static class ExampleExtension
	{
		public static int NumberWords(this string data)
		{
			тут описуємо потрібний функціонал
		}	
	}

	і тепер моє можливість визивати str.NumberWords
	
1. Метод должен быть static
2. Метод должен быть внутри static класса
3. Первый параметр метода должен иметь ключевое слово this:
Ключевое слово this указывает компилятору, что этот метод можно вызывать как будто он встроен в тип string.

    public static class StringExtensions
    {
        public static bool IsPalindrome(this string str)
        {
            string reversed = new string(str.Reverse().ToArray());
            return reversed == str;
        }
	}
	
	
========================================================
13_GarbageCollector_Dictionary

Garbage Collector - автоматичний механізм очищення памяті.
Він є недермінованим обєктом, ми не знаєм коли CLR вирішить стерти память

Обєкт існує в хіпі поки є хоч одне посилання на цей обєкт у стеці

Виділення памяті в хіпі робить ComandLanguaheRuntime

Для визначення  використовується graph ????

Розділяється хіп на три покоління
Коли покоління заповнюється до кінця, тоді збирач сміття знищує

При процесі чистки нульового покоління, якщо залишилось посилання, переносяться на перше покоління

Аналогічно потім чиститься перше і обєкти на які є посилання переноситься у 2 покоління.

З другого вже нічого не переноситься, просто перевіряється чи є посилання

в C# дескруктор називається фіналізатор


========================================================
14_Dictionary

Словник - асоциативний контейнер. Є ключик і значення.  Він не складає відсортовано, Складає так як ми додаєм

Dictionary <string, string> countries = new Dictionary<string, string>();

foreach (KeyValuePair<string,string> country in countries ) - щоб пробіжатися по словнику

з домашки

            var voidOperations = new Dictionary<string, VoidOperation>
            {
                ["2.1"] = ops.ReplaceNegativesWithZero,
                ["2.2"] = ops.SortArray,
                ["2.3"] = ops.MoveEvensToStart,
            };
			
countries.Add(....)  - якщо такий ключ уже був, викине помилку

counties["CA"] = "Canada"; - додасть в словник, якщо ключа немає, а якщо ключ є то змінить значення

========================================================
15_01_Collection

Колекція - це об'єкт, який зберігає групу елементів, зазвичай одного типу. Колекції забезпечують механізми для зберігання, доступу, вставки, видалення та маніпулювання даними.


using System.Collections; 

Не женерік:

Вони не шаблонні, тобто все що додається стає обжект

ArrayList arrayList = new ArreyList();
Можна додавати все що є ОБЖЕКТОМ
але витягувати, дивитись це вже складно

Stack stack1 = new Stack(); - стек
first in last out

Boxing - переміщення обєктів із стека в хіп
- коли приводите один тип даних до іншого (перетворення)

Unboxing - це процес распаковки, із хіпа перенесення в стек

Із хіпа в стек, можуть бути проблеми

НЕ ДЖЕНЕРІКІ майже не використовуються

SortedList - словник, є ключ і значення, але замість ключа і значення можна покласти все що обжект
при ключиках 
І якщо використовувати різні типи данних то відсортувати не вийде і вибє помилку





========================================================
15_02_Generics

using System.Collections;

Generic collections
Вони шаблонні, вказується тип данних.

Collection<T>
List<T>
Dictionary<Tkey, TValue>
SortedList<Tkey, TValue> - сразу сортується по ключу
Stack<T>
Queue<T>
LinkedList<T>

що можна зробити генерік:
class
Structures
Collestion
Method
interfase
delegate

	Робимо делегат дженеріком (шаблонним)

public delegate Type SummaTemplate<Type>(Type a, Type b);
public delegate bool CompereDelegate<T1,T2>(T1 a, T2 b);

main
	CompereDelegate<double, decimal> compare = Compare; (Compare - функція що створена вручну, compare - назва обєкту)
	
	Дженерік інтерфейс
interface IMyComparable<T>

	Дженерік класс 
class MyClass<Type> 
	{
		private Type[] array;

Limit - в лімітах прописуємо що може бути під Т1 і Т2

class Point<T1,T2> where T1:

	Дженерік функції
	
        static void ShowObject<T>(T obj)
        {
            //Console.WriteLine(obj);
            Console.WriteLine(obj.ToString());
        }
	
========================================================
16_WorkWithFile

Робота з файлами

System IO - дає нам класи, делегати, енами для роботи з файлами

Головний класс:

Stream =>
	FileStream
	MemoryStream
	BufferesStream

	static void WriteFile(string path)
	{
		FileStream fileStream = new FileStream("text.txt, FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read | FileShare.Write);
		
		try{
			doing...
		}
		finally
		{
			FileStream.Close();
		}
		
	}


FileMode - вибір методу роботи з файлом
FileAccess - вид доступу
FileShare - режим спільного користування

або краще використовувати юсінг. В дужках створюємо класс і працюємо всередині функції, потім сам юзінг і почистить память. Робимо запис в файл з стрінги, перетвоючі її в байти



	write file:

        static void WriteFile(string path)
        {
			using(FileStream fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.none))
	       using (FileStream fs = new FileStream(path, FileMode.Create, 
                FileAccess.Write,FileShare.None))
            {

                Console.WriteLine("Enter some text : ");
                string writeText = Console.ReadLine();

                byte[] writeBites = Encoding.Default.GetBytes(writeText);
                fs.Write(writeBites,0, writeBites.Length);

                Console.WriteLine("File was recorded!!!!");
	
	}
        static string ReadFile(string path)
        {
            using (FileStream fs = new FileStream(path, FileMode.Open,
                FileAccess.Read))
            {
                byte[]readBytes = new byte[fs.Length];
                fs.Read(readBytes, 0, readBytes.Length);
                return Encoding.Default.GetString(readBytes);
            }
        }
		
	А це вже стрінга без перетворення на байти	
	
        static void WriteTextFormat(string path)
        {
            using (StreamWriter sw = new StreamWriter(path))
            {
                sw.Write("Hello!");
                sw.Write("Hello!");
                sw.Write("Hello!");
                sw.Write("Hello!");
                sw.WriteLine("How are you?");
                sw.WriteLine("How are you?");
                sw.WriteLine("How are you?");
            }
        }
        static void ReadTextFormat(string path)
        {
            using (StreamReader sr = new StreamReader(path))
            {
                //sr.Read();
                //sr.ReadBlock();
                //sr.ReadLine();
                //sr.ReadToEnd();

                while (!sr.EndOfStream)
                {
                    Console.WriteLine(sr.ReadLine() + "!!!");
                }
            }
        }

File.WriteAllText(@"test3.txt", "Hello"); - і відкрило і записало і закрило  - це по стринзі


Binary Writer, Binary Reading

            //file = File.Create(@"test1.txt");

    
            //// 1.
            //var writer = new StreamWriter(file);
            //writer.Write("Hello");
            //writer.WriteLine("\tworld");
            //writer.Close();
            //file?.Close(); // null-conditional operator

            //// 2.
            //writer = File.CreateText(@"test2.txt");
            //writer.WriteLine("Hello");
            //writer.Close();

            //// 3.
            //File.WriteAllText(@"test3.txt", "Hello");
			
do
{

	DirectoryInfo dir = new DirectoryInfo(path);
	???????
}


========================================================
17_01_Attributes
Атрибути

Додаткові дані що ставляться у квадратних дужках перед классом

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class)] - вказується де цей атрибут можна використовувати

class CoderAttribute : Attribute    - тепер це клас атрибут

	public string Name
	
	public Data Time
	
		

[Obsolete] - застарілий, він не є актуальним і його не варто використовутати

[Serializable] - помічає клас таким, який можна сиролізувати


main 

            Console.WriteLine("Attributes of class Employee");
            foreach (var item in typeof(Employee).GetCustomAttributes(true))
            {
                Console.WriteLine(item);
            } - достає всі атриьбути в чьому атрибуті
	
            Console.WriteLine("Attributes of members of class Employee"); 
            foreach (MemberInfo item in typeof(Employee).GetMembers()) - всі мембери (всі сетери гетери, змінні, проперті)
            {
                Console.WriteLine("\t" + item.ToString());
                foreach (var attr in item.GetCustomAttributes<CoderAttribute>(true)) - все що є в мемберах ( у кожного проперті і або метода може бути всередині ще атрибут
                {
                    Console.WriteLine("\t\t" + attr);
                }
            }


========================================================
17_2_BinarySerialize


Серіалізація - це процес збереження стану обєкта в будь якому потоці з можливістю його відновлення. 
Беремо обєкт, перетворюємо в масив байтів, і записуємо до файлу

бінарна серіалізація вимагає атрибут [Serializable], а не скрізь його можна указати


========================================================
17_3_XML_JsonSerialization

в XML or JSON, не треба ставити атрибут [Serializable]

main

            List<Person> persons = new List<Person>()
            {
              new Person(123654){ Name="Jack", Age = 15},
              new Person(123654){ Name="Tom", Age = 12},
              new Person(123654){ Name="Bill", Age = 35},
              new Person(123654){ Name="John", Age = 47}
            };
            string fileName = "Person.json";
            string jsonString = JsonSerializer.Serialize(persons);
            File.WriteAllText(fileName, jsonString);


            List<Person> newPersons = null;
            jsonString = File.ReadAllText(fileName);
            newPersons = JsonSerializer.Deserialize<List<Person>>(jsonString)!;
         
            foreach (var item in newPersons)
            {
                Console.WriteLine(item);
            }

========================================================
17_4_DataAnnotation

Data Annotation - дозволяють перевіряти проперті коли вони валідні

реално використовуються 
	Атрибути 
	серіалізація

    class User
    {
        [Required(ErrorMessage ="Id not defined")]
        public int Id { get; set; }

        [Required(ErrorMessage ="Name not setted")]
        [StringLength(50,MinimumLength =3, ErrorMessage = "Wrong lenght")]
        public string Name { get; set; }
        [Required(ErrorMessage ="Age not setted")]
        [Range(1,125,ErrorMessage ="Wrong age")]
        public int Age { get; set; }
        [EmailAddress]
        public string Email { get; set; }
        [Required]
        public string Login { get; set; }
        [Required]
        public string Password { get; set; }
        [Required]
        [Compare(nameof( Password),ErrorMessage ="Not confirm password")]
        public string ConfirmPassword { get; set; }
        [Phone]
        public string Phone { get; set; }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            User user = new User();
            bool isValid = true;
            do
            {
                Console.WriteLine("Enter name:");
                string name = Console.ReadLine()!;

                Console.WriteLine("Enter age");
                int age = int.Parse(Console.ReadLine()!);

                Console.WriteLine("Enter Login");
                string login = Console.ReadLine()!;

                Console.WriteLine("Enter password");
                string password = Console.ReadLine()!;

                Console.WriteLine("Confirm password");
                string confirmPassword = Console.ReadLine()!;

                Console.WriteLine("Enter email");
                string email = Console.ReadLine()!;

                Console.WriteLine("Enter phone");
                string phone = Console.ReadLine()!;


                user.Id = 1;
                user.Name = name;
                user.Age = age;
                user.Password = password;
                user.ConfirmPassword = confirmPassword;
                user.Email = email;
                user.Phone = phone;
                user.Login = login;




                var result = new List<ValidationResult>();
                var context = new ValidationContext(user);
                if (!(isValid = Validator.TryValidateObject(user, context, result, true)))
                {
                    foreach (ValidationResult error in result)
                    {
                        Console.WriteLine(error.MemberNames.FirstOrDefault() + ": " + error.ErrorMessage);
                    }
                }


            } while (!isValid);

            Console.WriteLine("Model is valid");
        }
    }

========================================================
18_RegularExpression

Regex перевіряє чи по віпдовідає стрінга паттерну

string pattern2 = "....";
Redex redex2 = new Redex (pattern2);
bool flag =  redex2.IsMatch(str2);  (true or false)

Match m = Regex.Match(str2,@"\d");


            string value1 = "saidsaid said shed shed see sprear spread super";
            MatchCollection coll =  Regex.Matches(value1, @"s\w+d");
            foreach (Match match in coll)
            {
                Console.WriteLine($"Index = {match.Index}. Value : {match.Value}");
            }
            string inputString = "Don't replace Dot Net replaced Net Net dots";

            string output = Regex.Replace(inputString, "N.t", "NET");
            Console.WriteLine(output);


"^[A-Z][a-z]*$"    ^ на початку і $ в кінці значить щоб буквально всьому паттерну відповідає

saschadens.github.io

.		any character except newline
\w \d \s	word, digit, whitespace
\W \D \S	not word, not digit, not whitespace
[abc]	any of a, b, or c
[^abc]	not a, b, or c
[a-g]	character between a & g
^abc$	start / end of the string
\b		word boundary
\. \* \\	escaped special characters
\t \n \r	tab, linefeed, carriage return

a* a+ a?	0 or more, 1 or more, 0 or 1
a{5} a{2,}	exactly five, two or more
a{1,3}		between one & three
a+? a{2,}?	match as few as possible
ab|cd		match ab or cd


                СПЕЦ. СИМВОЛИ
                \d - Визначає символи цифр. 
                \D - Визначає любий символ, який не є цифрою. 
                \w - Визначає любий символ цифри, букви або нижнє підкреслення. 
                \W - Визначає любий символ, який не є цифрою, буквою або нижнім 
                     підкресленням.. 
                \s - Визначає любий недрукований символ, включаючи пробіл. (таб і 
                     перехід на новий рядок)
                \S - Визначає любий символ, крім символів табуляции, нового рядка 
                     и повернення каретки.
                .  - Визначає любий символ крім символа нового рядка.  
                \. - Визначає символ крапки.

            КВАНТИФИКАТОРЫ
            ^ - з початку рядка. 
            $ - з кінця рядка. 
            * - нуль і більше входжень підшаблону в сторці.  
            + - одне і більше  входжень підшаблону в сторці.  
            ? - нуль чи одне  входження підшаблону в сторці.  

========================================================
19_LINQ

Language Integrated Quary - інтегрована мова запитів, набір стандартних методів роботи з колекціями

Має обовязково інтерфейс IEnumerable

    LINQ to Objects:        применяется для работы с массивами и коллекциями    
    LINQ to Entities:       используется при обращении к базам данных через технологию Entity Framework
    LINQ to Sql:      технология доступа к данным в MS SQL Server
    LINQ to XML:   применяется при работе с файлами XML
    LINQ to DataSet:  применяется при работе с объектом DataSet
    Parallel LINQ (PLINQ):  используется для выполнения параллельной запросов 
	
	


            // Список используемых методов расширения LINQ

Select: определяет проекцию выбранных значений

Where: определяет фильтр выборки

OrderBy: упорядочивает элементы по возрастанию

OrderByDescending: упорядочивает элементы по убыванию

ThenBy: задает дополнительные критерии для упорядочивания элементов возрастанию

ThenByDescending: задает дополнительные критерии для упорядочивания элементов по убыванию

Join: соединяет две коллекции по определенному признаку

GroupBy: группирует элементы по ключу

ToLookup: группирует элементы по ключу, при этом все элементы 
          добавляются в словарь

GroupJoin: выполняет одновременно соединение коллекций и группировку элементов по ключу

Reverse: располагает элементы в обратном порядке

All: определяет, все ли элементы коллекции удовлятворяют определенному условию

Any: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию

Contains: определяет, содержит ли коллекция определенный элемент

Distinct: удаляет дублирующиеся элементы из коллекции

Except: возвращает разность двух коллекцию, то есть те элементы, которые содератся только в одной коллекции

Union: объединяет две однородные коллекции

Intersect: возвращает пересечение двух коллекций, то есть те элементы, 
           которые встречаются в обоих коллекциях

Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

Sum: подсчитывает сумму числовых значений в коллекции

Average: подсчитывает cреднее значение числовых значений в коллекции

Min: находит минимальное значение

Max: находит максимальное значение

Take: выбирает определенное количество элементов

Skip: пропускает определенное количество элементов

TakeWhile: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно

SkipWhile: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы

Concat: объединяет две коллекции

Zip: объединяет две коллекции в соответствии с определенным условием

First: выбирает первый элемент коллекции

FirstOrDefault: выбирает первый элемент коллекции или 
возвращает значение по умолчанию

Single: выбирает единственный элемент коллекции, если коллекция содердит больше или меньше одного элемента, то генерируется исключение

SingleOrDefault: выбирает первый элемент коллекции или возвращает значение по умолчанию

ElementAt: выбирает элемент последовательности по определенному индексу

ElementAtOrDefault: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона

Last: выбирает последний элемент коллекции

LastOrDefault: выбирает последний элемент коллекции 
       или возвращает значение по умолчанию



синтаксист запиту і синтаксиз методу

	
res = from elem in sourse  - схожий на форіч
select elem;

var auery = from i in arr select i; - оригінал не змінюється, працюємо з копіями


		!Процес відкладеного завантаження !
- якщо зробити квері, і потім не використовувати, то власне запит не буде оброблятися. І тільки якщо використовується то повертається до квері і виконує запит


синтаксист запиту:

		IEnumerable<int> query = from i in arr select i*-1;
або
            var Query = from i in arrInt
                        where i%2 == 0
                        select i * -1; 
	- селект працює як ретурн, в цьому випадку кожен елемент множиться на -1. оригінал не змінюється, працюємо з копіями

синтаксист методу:

	var result2 = words.Where(word=>word.Length == 4; 		
	- якщо нічного не змінюємо то select можна не писати

	
	
	            Product[] products = { 
                new Product(){ Name = "Apple", Category ="Food"},
                new Product(){ Name = "Phone", Category ="Tech"},
                new Product(){ Name = "Laptop", Category ="Tech"},
                new Product(){ Name = "Banana", Category ="Food"},
                new Product(){ Name = "Pelmen", Category ="Food"}
            };
            var results = products.GroupBy(p => p.Category);
            foreach (IGrouping<string, Product> item in results)
            {
                Console.Write(item.Key + " - ");
                foreach (Product elem in item)
                {
                    Console.Write(elem + " ");
                }
                Console.WriteLine();
            }  групування по категории, потом вывод на экран. Получается колекция обектов кколекций. Колекция категорий, обэктами которой являются продукты
			

	групування завжди словник
	
	Всі  вертають колекцію, крім:
	Агрегаційні функції - вертають один результат
Count: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

Sum: подсчитывает сумму числовых значений в коллекции

Average: подсчитывает cреднее значение числовых значений в коллекции

Min: находит минимальное значение

Max: находит максимальное значение
	
	Sum, Average працює тільки з числами
	
	soft.Except(hard); - чим відрізняються хард від софта
	
	
            // Except -----------------------        
            // знаходимо різницю між двома колекціями
            //чим колекція hard відрізняється від soft
            //result3 = soft.Except(hard);           
            //result3 = hard.Except(soft);
            // Intersect ---------------------------
            // отримуємо елементи колекції А, які присутні в колекції В (без дублікатів)
            //result3 = soft.Intersect(hard);           

            // Union ---------------------------
            // з'єднує елементи двох колекцій (без дублікатів)
            //result3 = soft.Union(hard);
          

            // Concat -------------
            // з'єднує елементи двох колекцій
            //result3 = soft.Concat(hard);

            // Distinct ----------------
            // видаляє дублікати
            result3 = soft.Distinct();



















	









