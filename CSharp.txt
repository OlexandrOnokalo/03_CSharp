01_IntroToDotNet
 

Credential Manager

C# - побудована і працює на платформі .NET

.NET Core дозволяє створюватти кросплатформенні додатки

C#  - це чисто ПОО мова програмування

Середовища виконання: Command langauge Run Time (CLR)
CLR - менеджер між нашими класами, бібліотеками і операційною системою. Виділяє і чистить память.



visual studio installer -> modify -> .net deskstop development -> instal

cw + TAB - Console.WriteLine("") - вивести на екран

C# data types  - static
	Value types  -  unNullable 
		Simple types (int, float, char, bool
		enum, 
		struct 
		
	Reference Rypes - dynamic - Nullable 
		Class, array, interface, delegate
		
Типи данних:
	Цілі:
		byte  	 0 > 255
		sbyte	-128>127
		short	int16   -32 768 > 32767 
		ushort  0>65535
		int		- int32
		uint	
		long	-int64
		ulong
	Дробові:
		float (single)   - float h = 3.14f;
		double
		decimal   -  decimal p = 5.64m;
		
Console.Readline()!;

int number = int.Parse(str); 

Console.WriteLine($"Number {numberStr}"); - інтерполяція


Console.OutputEncoding = Encoding.Unicode;
                \'      – single quote, needed for character literals
                \"      – double quote, needed for string literals
                \\      – backslash
                \0      – Unicode character 0
                \a      – Alert (character 7)
                \b      – Backspace (character 8)
                \f      – Form feed (character 12)
                \n      – New line (character 10)
                \r      – Carriage return (character 13)
                \t      – Horizontal tab (character 9)
                \v      – Vertical quote (character 11)
                \uxxxx  – Unicode escape sequence for character with hex value xxxx   
	
cw + TAB - Console.WriteLine("")
Console.Readline()!;

            //изменяет цвет фона
            Console.BackgroundColor = ConsoleColor.Green;
            //изменяет цвет текста                      
            Console.ForegroundColor = ConsoleColor.Magenta;
			Console.ResetColor();

DateTime now = DateTime.Now;

cw + TAB - Console.WriteLine("") - вивести текст
Console.Write($"Number {i + 1}: "); - без переходу на новий рядок
	$"..." — це рядкова інтерполяція: дозволяє вставляти значення змінних або виразів прямо всередину рядка.
	Усередині фігурних дужок {} можна писати змінні або вирази.
string input = Console.ReadLine(); - зчитати текст
numbers[i] = int.Parse(Console.ReadLine())!; - int.Parse — перетворює рядок у ціле число

int[] numbers = new int[5]; - массив

	foreach (int num in numbers)
        {
		sum += num;
        product *= num;
        if (num < min) min = num;
        if (num > max) max = num;
        }





========================================================
02_Array

Array - батьківський клас всіх масивів. Зберігаються в динамічній памяті

Створення нового масиву
Пустий масив:
	int[] arr = new int[8];
Пусті комірки зайняті нулями

int[]arr2 = new int[] {1,2,3,4,5}; - список інізіалізації, саме рахує кількість елементів, можна сайз не вказувати

	int []arr4 = [10,20,30]; - коротший варінт
	
	arr5.SetValue(77,2;
	
	for може редагувати, лізе в кожну комірку по індексу
	
	foreach (var elem in arr5) - може тільки виводити, бо кожне значення копіює в змінну елем, немає доступу до оригіналу, і є готовий інумінатор

Двовимірний масив:
	int[,] array = new int [3,3];
	
	array.Length - загальна кількійсть комірок
	array.GetLength(0) - показує довжину рядка

є тровимірні і так далі

Рваний масив (зубчастий) - двовимірний масив - є рядочкі, але в рідках різна кількість комірок
	int[][] jagged = new int[3][];

	int[] temparr = (int[]) arr.Clone(); - клонування масива

        Random random = new Random();
        double res = random.Next(100) + random.NextDouble();
        Console.WriteLine(res);

		res = Math.Round(res, 2); - обрізати до 2 символів після коми
        Console.WriteLine(res);


static function?
abstruct ?

	
========================================================
03_String
	
	string[] array = { "Hello", "From", "Summer", "Sun", "Tree", "Lake" };
	
	string message = string.Join(" - ", array); - з масиву стрінг у одну стрінгу
	
	string []splictArr = message.Split(new string[] {" - "}, StringSplitOptions.None); - просто порізати по розділювачу
	
	string []words = htmlMessage.Split(new char[] { ' ', '.', ',', '!', '/', '-', '?' }, StringSplitOptions.RemoveEmptyEntries); - порізати по купі розділювачів, і з опцією не враховувати пробіли 
	
	ConsoleKeyInfo key =  Console.ReadKey(); - бере один "ключ" - кнопку на клавіатурі
	if(key.Key == ConsoleKey.F12) - от тут нажата ф12

	if (string.IsNullOrEmpty(nullStr) або просто посилання, або стрінга створена з "" (тобто пуста)
	if (string.IsNullOrWhiteSpace(str2)) - або просто посилання або пробіли
	
Зрівнюємо 2 стрінги
	
	if (string.Compare(str11, str12) == 0)
	
String Contains String

    string str3 = "This is testing";
    if (str3.Contains("test"))	
	
Вирізати частину тексту
	string substr = str4.Substring(23); - з 23 індексу до кінця
	string substr = str4.Substring(23,5); - з 23 індексу 5 символів
	
Зєднуємо стрінги з массиву в одну
            string[] starray = new string[]{"Down, the way nights, are dark",
                                            "And the sun shines daily on the mountain top",
                                            "I took, a trip, on,a sailing ship",
                                            "And when I reached Jamaica",
                                            "I made a stop"};

            string str5 = string.Join("!\n", starray);
	
Конкатанація (додавання)
            string s1 = "hello";
            string s2 = "world";
            string s3 = s1 + " " + s2; // = string "hello world"
	
03_02_StringBuilder

	StringBuilder stringBuilder = new StringBuilder(); - кожен раз як не влазить новий розмір зарезервованих комірок в 2 р більше

	Console.WriteLine("Capacity : " + stringBuilder.Capacity); - кількість зарезервованих комірок
	Console.WriteLine("Length : " + stringBuilder.Length); - кількість зайнятих комірок
	
	stringBuilder.Append("Hello"); - додаємо в кінець
	stringBuilder.AppendLine("Hello"); - додає і в кінці \n

========================================================
04_IntroToOOP

class - можливість зробити свій тип данних

	private, public, protected - так само як на С++
	internal - дає доступ тільки до цього класу тільки в цьому проєкту
	protected internal - наслідники в межах цієї збірки (проекта)
	
class Point
{
	private int numder;   (для кожної змінної прописуємо 

}
дочірній клас:
class Child: Point  (public по замовчуванні і змінити не можеш)



	class Point
{
		private int numder;   (для кожної змінної прописуємо 
		private string name;
		privat const float PI=3.14f;   - не можна інізіалізувати в 	конструкторі
		private readonly int id = 1; - можна інізіалізатувати в конструкторі

}



partial class Point : Object - в любому випадку батьківський класс обж, партіал дає можливість розділити класс на частини


Property - це властивість яка робить змінну контрольованою, всередині ми можемо зробити валідацію.


fullproperty ---> propfull + Tab



partial class Point
    {
        private int xCoord;   - приватна змінна
 
        public int XCoord      - проперті до цієї змінної (
        {
            get { return xCoord; }
            set
            {
                if (value >= 0)			- перевірка для сеттера
                    xCoord = value;
                else
                    xCoord = 0;
            }
        }
        private int yCoord;
        public int YCoord
        {
            get { return yCoord; }
            set
            {
                if (value >= 0)
                    yCoord = value;
                else
                    yCoord = 0;
            }
        }

автопроперті:
Auto property ---> prop + Tab

public string Name { get; set; } - автопроперті
		
		
		
		
		
		public void Print()  - принт по старинці
        {
            Console.WriteLine($"X : {xCoord}, Y : {yCoord}");
            //Console.SetCursorPosition(xCoord, yCoord); Console.WriteLine("*");
        }
        public override string ToString() - перевантажена функція від батьківського классу
        {
            return $"X : {xCoord}, Y : {yCoord}";
        }
		
		
		    p.XCoord = 1000;   //value = 1000 - setter
            Console.WriteLine(p.XCoord);    //getter
		
		
для звернення до проперті в майн:

	
Worker w = new Worker;

w.Name - якщо немає дорувнює, спрацьовує гетер і виведе значення

w.Age = 18; - є дорівнює, спрацьовує сеттер і запише нове значення




struct NewPoint { -  структура не може мати наслідників


поділ на файли
partial - дозволяє ділити класси на частини

			static

Статичне поле — це змінна, яка:
	належить не конкретному об’єкту, а всьому класу в цілому;
	існує в єдиному екземплярі незалежно від кількості створених об'єктів;
	має спільне значення для всіх екземплярів класу.
Статичний метод — це метод, який також належить класу, а не окремому об’єкту, і може працювати тільки зі статичними полями або параметрами.

 Что такое статический конструктор в C#?
Статический конструктор — это специальный конструктор, который:
	выполняется автоматически один раз, перед первым использованием класса (до создания первого объекта или вызова любого статического члена).
	не принимает параметров
	не вызывается вручную
	используется для инициализации статических полей

========================================================
05_StructRefOut

struct NewPoint { -  структура не може мати наслідників, все що є в середині паблік
Містить конструктор і прінт



Якщо треба мати два класса з однією назваою, можна розбивати на namespase

_2D_Object.Point p   - вказуємо найм спейс якщо мейн не в цьому неймспейсі

Ref - references - створює посилання по якій буде давати доступ до оригіналу

Point point = new Point() {X = 10, Y = 15}  - створення обєкту без конструктора

        static void Modify(int num, string str, Point point)
        {
            num += 1;
            str += "!!!";    просто копії і стираються, оригінал не зміниться, бо це валує тип
            point.X++;
            point.Y++;   приходить копія посилання, оригінал зміниться
        }


	!!!Дуже важливо копію чого ми передаємо

в валує просто копія
в референс передається копія адреси
для стрінги і масивів не підходить, бо перевидається память і нова адреса

ref - це посилання, замість & в плюсах
Це ключеве слово, яке передає доступ до оригіналу з середини методу

!!!Може дозволяє змінити тількі інізіалізовану змінну

        }
        static void Modify(ref int num, ref string str, ref Point point)
        {
            num += 1;
            str += "!!!";
            point.X++;
            point.Y++;  
        }
	
ref - працює з оригіналом, якщо змінна не ініціалізована, помилка

Out  - працює з оригіналом, але може сам ініціалізувати змінні, навіть якщо вони не ініціалізована, або навіть не створена


        static void GetCurrentTime(out int hour,out  int minute ,out int second)
        {
            hour = DateTime.Now.Hour;
            minute = DateTime.Now.Minute;
            second = DateTime.Now.Second;
                    
        }
main
            GetCurrentTime(out h,out m, out s);
            
            Console.WriteLine($"{h}:{m}:{s}");

Змінних h, m, s не існувало в мейні. Коли визвалась функція static void GetCurrentTime(out int hour,out  int minute ,out int second), всередині функції були зроблені змінні hour, minute, second, ініціалізовані, і збережені у вигляді нових змінних ззовні (у мейн) h,m,s


Структури зберігається в стекі
Класси в динамічній памяті, АЛЕ:

	new

Коли ми робимо пустий КЛАСС,  запускається ДЕФОЛТНИЙ КОНСТРУКТОР і створюється послання і точно виділяється динамічна память і заповнюються нулями

в СТРУКТУРІ дефолтний конструктор чипати не можна, бо він запускається і записує в СТЕК дефлотні значення

	
========================================================
06_Exception


if (y==0)
{
	throw new Exception ("описуємо від себе помилку")
}


try  -запускає код
{
	ризикований код
}
catch (Exception ex) - ловить помилку
{
    Console.WriteLine($"Error: {ex.Message}");
}

finaly   - це такий блок який запускається безумовно в кінці трай, туди пишемо закриття файлів, підключень і тд
{
	
}  


	byte b = 100;
	b = (byte)(b+200); - переповнено, ма
	
try
	checked   - перевіряє
		b++;
		
		
	unchked
	
	byte b = 100;
	
	
				Namespace
				
Можна робити різні неймспейси, і розміщювати класи з одним імям в кожному і через неймспейси посилатись

A.Incrementer()  - функція з неймспейс А

using A;   - підключяаємо просто цей нейспейс А

    https://github.com/IliushynOlena/Exceptions
    https://github.com/IliushynOlena/c_charp_namespaces

========================================================
07_OverloadOperator


_3dpoint



class Point
{
	public int X ...
	public int Y...
	
	перезавантажений оператор + СТАТИЧНИЙ (не має this)
	public static return_type operator +(parameters)
	

!!!!!!!!!! тут про оператори описати

 унарний -	не змінює оригінал а повертає новий поінт
 унарний ++   - завжди міняє оригінал, виводить ++point (все одно спрацьовує префіксна форма, навіть коли вказується point++
 
 бінарний
 
 порівняння
 
		<  - для перезавантаження треба зробити ще оператор >, вони працюють в парі
 
 рівності
 
	true/false  - також працюють тільки в парі
	
  overload types - перезавантаження типів даних
	
			3d...     -   _3d_Point це і назва оператора і результат ретурна
			
			

	


